// SimplePacket.h

#ifndef _SERIALIZABLE_H_
#define _SERIALIZABLE_H_
#if defined(ARDUINO) && ARDUINO >= 100
#include "arduino.h"
#else
#include "WProgram.h"
#endif

#define SIMPLE_PACKET_STARTER '#'
#define SIMPLE_PACKET_SEPARATOR	','

/*
How to implement your own packets?
 1. Sub-classing 'Serializable'
 2. Defining sub-class's data fields
 3. implement 'Serializable::serializeImpl' and 'Serializable::deserializeImpl' 
    for loading and unloading data fields defined at 2.
 4. implement 'Serializable::getTypeField' such that a unique string is returned for distinguish each packets.

class PacketTimeStamp:public Serializable{
public:
	const char* getTypeField() const{
		return "STAMP";
	}

	bool serializeImpl(SerializeHelper::PacketLoader& loader){
		loader.load(String(_stamp));
		return true;//This is required.
	}

	bool deserializeImpl(SerializeHelper::PacketUnloader& unloader){
		String field;
		if(!unloader.unload(field)){
			return false;
		}
		_stamp = field.toInto();
		return true;
	}
protected:
	int32_t _stamp;
};
*/

namespace SerializeHelper{
	/*
	Concatenate data fields after a String data and a precedent
	separating charactor('SIMPLE_PACKET_SEPARATOR') is added automatically.
	*/
	class PacketLoader{
	public:
		PacketLoader(String& data);

		void load(const String& field);
	private:
		String& _data;
	};

	/*
	Split data fields from a String data using 'SIMPLE_PACKET_SEPARATOR'.
	*/
	class PacketUnloader{
	public:
		PacketUnloader(const String& data, const size_t& idx_from);
		PacketUnloader(const String& data, const size_t& idx_from, const size_t& idx_end);
		bool unload(String& field);
	private:
		const String& _data;
		size_t _idx_from;
		size_t _idx_end;
		size_t _idx;
	};
}

class Serializable{
public:
	enum SerializeErrors{
		No_Error = 0,
		Packet_Is_Too_Short = 1,
		Invalid_PacketStarter = 2,
		CheckSum_Not_Match = 3,
		TypeField_Not_Match = 4,
		TypeField_Extract_Failed = 5,
		UserSerialize_Error = 6,
		UserDeserialize_Error = 7
	};

	Serializable() :_last_error(No_Error){
		clearUpdated();
	}

	virtual ~Serializable(){}

	static String ExtractTypeField(const String& packet);

	/*

	*/
	bool serialize(String& packet);

	/*
	Perform minimal checkes for verifying a packet before deserialization.
	If it returns other than 'No_Error', the packet is invalid that no additional deserialization is required.
	Possibilities are
	- the packet was not generated by this class
	- there's packet loss
	
	!'packet' must be TRIMMED beforehand.
	*/
	static bool isValid(const String& packet);

	/*
	It is assumed that 'packet' is verified by isValid() method.
	*/
	bool deserialize(const String& packet);

	virtual const char* getTypeField() const = 0;

	inline void clearUpdated(){
		_updated = false;
	}

	/*
	return true, if last deserialization succeeded.
	return false, if last deserialization failed or clearUpdated() was called.
	*/
	inline bool isUpdated() const{
		return _updated;
	}

	inline SerializeErrors getLastError() const{
		return _last_error;
	}
protected:
	inline void setUpdated(){
		_updated = true;
	}

	/*
	Each packet type must implement this method to create a packet.
	*/
	virtual bool serializeImpl(SerializeHelper::PacketLoader& loader) = 0;
	/*
	Each packet type must implement this method to parse data from a packet.
	*/
	virtual bool deserializeImpl(SerializeHelper::PacketUnloader& unloader) = 0;
private:
	/*
	Checksum is computed from SIMPLE_PACKET_STARTER upto a byte right before check-sum field(
	excluding SIMPLE_PACKET_SEPARATOR).
	*/
	static String computeCheckSum(const String& data, const size_t& idx_from, const size_t& idx_end);

	static String toHex(char val);

	inline SerializeErrors setLastError(const SerializeErrors& err) {
		return _last_error = err;
	}
private:
	bool _updated;
	SerializeErrors _last_error;
};

#endif

